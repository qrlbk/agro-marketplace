# Мониторинг и проверка безопасности

Документ фиксирует результаты проверки по пунктам: IDOR, админка, rate-limiting, санитизация ввода, RLS, пароли и JWT.

---

## 1. IDOR (Insecure Direct Object Reference)

**Риск:** пользователь подставляет чужой ID в запросе и получает доступ к чужим данным.

**Проверено:**

| Эндпоинт | Проверка доступа |
|----------|-------------------|
| `GET/PATCH /orders/{order_id}` | Доступ только если `order.user_id == current_user.id` (покупатель), или `order.vendor_id == current_user.id`, или тот же vendor по компании, или `UserRole.admin`. |
| `GET/DELETE /garage/machines/{garage_id}` | В выборке всегда `Garage.user_id == current_user.id`. |
| `GET/PATCH /notifications/{notification_id}/read` | В выборке `Notification.user_id == current_user.id`. |
| `GET /chat/sessions/{session_id}/messages` | В выборке `ChatSession.user_id == current_user.id`. |
| `POST /feedback` с `order_id` | Проверка `order.user_id == current_user.id` перед привязкой заказа к обращению. |
| Товары, корзина, чекаут | Корзина и заказы привязаны к `current_user.id`; товары читаются по каталогу без привязки к пользователю. |

**Админские маршруты** (`/admin/*`): доступ к произвольным `user_id`, `order_id`, `company_id` по дизайну — только для пользователей с ролью админ или staff с нужным permission; все эндпоинты защищены через `require_admin_or_staff("...")` или `get_current_admin`.

**Рекомендация:** при добавлении новых эндпоинтов с ID в пути всегда фильтровать по владельцу (или по роли для админки).

---

## 2. Админка: проверка роли

**Риск:** в админку может зайти кто угодно.

**Проверено:**

- Все маршруты под префиксом `/admin` защищены зависимостями:
  - `require_admin_or_staff("permission_code")` — доступ есть у marketplace User с ролью `admin` или у Staff с указанной permission;
  - для категорий используется `get_current_admin` (только marketplace admin).
- Маршруты Staff portal (`/staff/*`) защищены `get_current_staff` или `get_current_staff_with_permission(...)`.

**Отдельных маршрутов без проверки роли/прав в админке и staff не обнаружено.**

---

## 3. Rate-limiting (защита от брутфорса)

**Проверено и настроено:**

| Эндпоинт / сценарий | Ограничение |
|----------------------|-------------|
| `POST /auth/request-otp` | По номеру телефона и по IP (окно и лимиты в `config`: `otp_rate_limit_per_phone`, `otp_rate_limit_per_ip`, `otp_rate_limit_window_seconds`). |
| `POST /auth/verify-otp` | Лимиты по телефону и IP + блокировка после N неудачных попыток (`otp_verify_max_attempts`, `otpfail` в Redis). |
| `POST /auth/demo-login` | Лимит по IP: `demo_login_rate_limit_per_ip` попыток за `demo_login_rate_limit_window_seconds` (по умолчанию 10 за 300 с). |
| Staff login | Лимиты по логину и по IP (`staff_login_rate_limit_per_login`, `staff_login_rate_limit_per_ip`, окно в секундах). |
| Чат | Лимит запросов в минуту по пользователю или IP (`check_chat_rate_limit`). |

**Рекомендация:** при добавлении новых эндпоинтов входа или чувствительных действий добавлять rate limit по IP и при необходимости по идентификатору пользователя.

---

## 4. Санитизация входящих данных

**Риск:** «что пришло, то ушло в БД» — управляющие символы, слишком длинные строки, потенциально опасные последовательности.

**Сделано:**

- Введён модуль `app.utils.sanitize`: `sanitize_text()` / `sanitize_text_required()`:
  - обрезка пробелов по краям;
  - нормализация Unicode (NFC);
  - удаление управляющих символов (C0, C1, DEL);
  - при необходимости ограничение длины строки.
- Санитизация перед записью в БД применена к:
  - профилю пользователя: имя (`PATCH /auth/me`);
  - обращению: тема, текст, контактный телефон (`POST /feedback`);
  - заказу: адрес доставки, комментарий (`POST /checkout`).

**Рекомендация:** для всех новых текстовых полей от пользователя перед сохранением вызывать `sanitize_text(..., max_length=...)` с лимитом по схеме/колонке. SQL-инъекции исключены за счёт ORM (параметризованные запросы).

---

## 5. RLS (Row Level Security)

**Текущее состояние:** в проекте **RLS в PostgreSQL не настраивается**. Разграничение доступа к строкам выполняется только на уровне приложения (проверки `current_user.id`, ролей и прав в эндпоинтах).

**Риск:** при ошибке в коде или обходе API (например, прямой доступ к БД) возможен доступ к чужим строкам.

**Рекомендация:** для повышения защиты в будущем рассмотреть включение RLS по таблицам (users, orders, notifications, feedback и т.д.) с политиками по `user_id` / `vendor_id` / `company_id`. Текущая реализация полагается на корректность проверок в API.

---

## 6. Пароли и JWT

**Пароли:**

- **Marketplace users:** входа по паролю нет; используется только OTP по телефону. Демо-логин сравнивает пароль с константой в коде (только при включённом демо и не в prod).
- **Staff:** пароли хранятся в виде хэша (bcrypt) в поле `staff.password_hash`; при логине проверка через `pwd_ctx.verify(password, staff.password_hash)`. В БД и в логах пароли не пишутся.

**JWT:**

- В payload маркетплейсного токена передаются только `sub` (user_id), `role`, `phone`, `exp`, `iss`. **Паролей и хэшей в JWT нет.**
- В payload staff-токена: `sub` (staff_id), `exp`, `permissions`, `iss`. **Паролей и хэшей в JWT нет.**

**Рекомендация:** при любом изменении формата JWT проверять, что в payload не попадают пароль, хэш пароля или иные секреты.

---

## Чек-лист при добавлении нового функционала

- [ ] Эндпоинты с ID в пути: проверка владельца или прав (admin/staff).
- [ ] Админские/Staff маршруты: зависимость `require_admin_or_staff(...)` или `get_current_staff_with_permission(...)`.
- [ ] Логин/регистрация/критичные действия: rate limit по IP (и при необходимости по пользователю).
- [ ] Текстовые поля от пользователя: санитизация через `sanitize_text` с ограничением длины перед записью в БД.
- [ ] JWT и ответы API: не возвращать и не класть в токен пароли, хэши, внутренние ошибки.

---

## 7. Мониторинг безопасности (проверка на баги)

**Дата проверки:** 2025-02-26.

### Найденные и исправленные уязвимости

| Проблема | Риск | Статус |
|----------|------|--------|
| **GET /health/openai без аутентификации** | Раскрытие информации: наличие OPENAI_API_KEY, сообщения об ошибках API, имя модели. Доступен любому без заголовка. | **Исправлено:** эндпоинт защищён через `_require_health_api_key(request)` так же, как `/health` и `/health/ready`. При заданном `HEALTH_API_KEY` требуется заголовок `x-health-api-key`. |

### Проверено, уязвимостей не обнаружено

- **IDOR:** заказы, чат-сессии, уведомления, feedback — везде проверка владельца или прав.
- **SQL-инъекции:** везде ORM/SQLAlchemy с параметрами; в admin audit fallback используется `text()` с `params` (без конкатенации строк).
- **Загрузка файлов (vendor):** имя файла не подставляется в путь — используется `uuid4().hex + ext`; расширение проверяется по whitelist; есть проверка MIME и опционально ClamAV.
- **JWT:** алгоритм из конфига (HS256), issuer различает marketplace и staff; `sub` приводится к int безопасно.
- **Вебхук 1C:** защищён `verify_webhook_1c_key` (X-API-Key).
- **XSS (фронт):** не найдено использования `dangerouslySetInnerHTML` / `innerHTML` / `eval`.
- **Админка и Staff:** все маршруты с зависимостями по роли/правам; категории POST/DELETE только для `get_current_admin`.

### Рекомендации для мониторинга

- В продакшене задавать `HEALTH_API_KEY` и не открывать `/health*` наружу без ключа (или закрыть их файрволом).
- Не использовать алгоритм JWT `none`; оставлять `jwt_algorithm` в whitelist (например, только HS256).
- При добавлении новых эндпоинтов с ID в path — сразу добавлять проверку владельца или прав в чек-лист выше.
